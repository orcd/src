
<!-- toc orderedList:0 -->

- [第十五章 Bash脚本编程](#第十五章-bash脚本编程)
	- [15.1 前言](#151-前言)
	- [15.2 变量](#152-变量)
		- [15.2.1 引用变量](#1521-引用变量)
		- [15.2.2 环境变量](#1522-环境变量)
		- [15.2.3 参数变量](#1523-参数变量)
		- [15.2.4 局部变量](#1524-局部变量)
		- [15.2.5 变量赋值](#1525-变量赋值)
		- [15.2.6 设置环境变量](#1526-设置环境变量)
		- [15.2.7 运算](#1527-运算)
	- [15.3 运行流程控制](#153-运行流程控制)
		- [15.3.1 if-else](#1531-if-else)
			- [15.3.1.1 数值条件](#15311-数值条件)
			- [15.4.1.2 字符串条件](#15412-字符串条件)
			- [15.4.1.3 文件条件](#15413-文件条件)
			- [15.4.1.4 逻辑表达式](#15414-逻辑表达式)
			- [15.4.1.5 条件短路](#15415-条件短路)
		- [15.3.2 循环](#1532-循环)
			- [15.3.2.1 for](#15321-for)
			- [15.3.2.2 while](#15322-while)
			- [15.3.2.2 break和continue](#15322-break和continue)
		- [15.3.3 分支](#1533-分支)
	- [15.4 模块化](#154-模块化)
		- [15.4.1 函数](#1541-函数)
		- [15.4.2 文件包含](#1542-文件包含)
		- [15.4.3 执行脚本](#1543-执行脚本)
	- [15.5 输入/输出和重定向](#155-输入输出和重定向)
		- [15.5.1 命令行参数](#1551-命令行参数)
		- [15.5.2 重定向输入](#1552-重定向输入)
		- [15.5.3 退出码](#1553-退出码)
		- [15.5.4 重定向输出](#1554-重定向输出)
		- [xargs](#xargs)
	- [15.6 高级Bash命令和正则表达式](#156-高级bash命令和正则表达式)
		- [15.6.1 正则表达式](#1561-正则表达式)
			- [15.6.1.1 例子](#15611-例子)
			- [15.6.1.2 元字符和转义](#15612-元字符和转义)
			- [16.6.1.3 重复](#16613-重复)
			- [16.6.1.4 分组](#16614-分组)
			- [16.6.1.5 选择](#16615-选择)
			- [16.6.1.6 贪婪和懒惰](#16616-贪婪和懒惰)
		- [15.6.2 awk](#1562-awk)
			- [15.6.2.1 前言](#15621-前言)
			- [15.6.2.2 awk结构](#15622-awk结构)
			- [15.6.2.3 输出](#15623-输出)
			- [15.6.2.4 pattern](#15624-pattern)
		- [15.6.3 sed](#1563-sed)
			- [15.6.3.1 前言](#15631-前言)
			- [15.6.3.2 命令格式](#15632-命令格式)

<!-- tocstop -->

# 第十五章 Bash脚本编程

## 15.1 前言
通过之前的学习，懂得了如何在Linux下进行编程来拓展系统功能。但是一些小功能，可以通过脚本直接实现，就没有必要使用C语言来编程实现。

脚本语言能快速实现一些功能，并且在不需要编译情况下直接运行。因此开发效率更高，但是运行效率略低。

就像编程语言有C/C++, JAVA，Basic等等一样，脚本语言也有许多，Linux下常用的Shell脚本有Bash，也是这个课程的重点。其他的脚本语言有：JavaScript，Lua，python，php等等。

```Bash
#!/bin/bash
echo "hello world"
```
将以上的代码保存到hello.sh，然后
脚本的运行需要脚本解析器，因为脚本程序是文本格式，CPU无法直接运行它，因此通过脚本解析器间接运行脚本程序。

`#`表示注释，但是第一行的`#`有特殊意义，用来指示解析器。

参考：
[http://www.runoob.com/linux/linux-shell.html](http://www.runoob.com/linux/linux-shell.html)

## 15.2 变量
在Bash中，可以访问的变量有环境变量、命令行参数和自定义变量。变量并没有类型，对于Bash来说都是字符串。
### 15.2.1 引用变量
使用`$var`或者`${var}`得到变量的值，建议使用`${var}`
### 15.2.2 环境变量
Bash脚本运行时，脚本可以访问环境变量
### 15.2.3 参数变量
如果执行脚本时，有携带参数，那么可以通过$1之类的方法访问参数。
> 脚本函数也是这样访问参数的

### 15.2.4 局部变量
可以自定义变量，但是要注意自定义变量时，等号左右不要有空格。

### 15.2.5 变量赋值
自定义变量可以通过=赋值，除了简单的赋值之外，有些注意的事项
- 赋值内容带空格时，需要加""，在Bash里，空格是分割符号，如果没有""，当然使用转义`\`也是可以的。
```Bash
var="hello world"
var=hello\ world
```
> 也可以用单引号来表示字符串

- 可以通过\`符号获得其他命令或者脚本的运行结果（标准输出），比如
```Bash
var=`ls -al`
```

### 15.2.6 设置环境变量
通过`export`命令可以修改环境变量，环境变量可以用于脚本解析器之间的参数传递。

> 思考：如果有一个环境变量和一个普通变量名是一样的，会是什么情况？

### 15.2.7 运算
Bash变量都是字符串，所以不能直接进行四则混合运算，可以通过`expr`命令间接实现。
```bash
xueguoliang@xueguoliang:~$ expr 1 + 2
3
xueguoliang@xueguoliang:~$ expr 3 \* 2
6
```
注意+号两边的空格是必须的，乘号*有特殊意义，所以需要`\`进行转义。

## 15.3 运行流程控制
### 15.3.1 if-else
```bash
if condition
then
  do something
fi
```
then单独一行，是必须的，如果想写成一个单行，也可以使用`;`分割。
```bash
if condition then; do something; fi
```

使用命令`man test`查看条件格式

#### 15.3.1.1 数值条件
```bash
var1=1
var2=2
if [ $var2 -gt $var1 ]
then
  echo "var2 is great then var1"
else
  echo "var2 is not great then var1"
fi
```
类似`-gt`，有`-ge`，`-lt`，`-le`，`-eq`，`-ne`等等。

#### 15.4.1.2 字符串条件
```bash
var1=a
var2=b
if [ $var1 = $var2 ]
then
  echo "var1 is equal var2"
fi
```
字符串的比较可以使用`=`和`!=`，以及使用`-n`和`-z`来表示是否为空。


#### 15.4.1.3 文件条件
```bash
var=/home/xueguoliang/a.txt
if [ -e $var ]
then
  echo "file exist";
fi
```
类似`-e`，还有`-d`，`-f`等
#### 15.4.1.4 逻辑表达式
```bash
var1=1
var2=2
if [ $var1 -eq 1 -a $var2 -eq 2 ]
then
  echo "var1 is 1 and var2 is 2"
fi
```
类似`-a`还有`-o`。也支持使用`C++`的`&&`和`||`来代替`-a`和`-o`。

使用`!`表示not，表示取反。

优先级 `!` > `-a` > `-o`

#### 15.4.1.5 条件短路
```bash
ls filename && echo "file exist"
```
```bash
! ls filename && echo "file not exist"
```
条件短路使用的是

### 15.3.2 循环
#### 15.3.2.1 for
```bash
vars="a b c d"
for var in $vars
do
  echo $var
done
```

#### 15.3.2.2 while
```Bash
var=1
sum=0
while [ $var -le 100 ]
do
  sum=`expr $var + $sum`
  var=`expr $var + 1`
done
echo $sum
```

#### 15.3.2.2 break和continue
与C语言类似。

### 15.3.3 分支
跟C语言的switch只能使用整数不同，Bash的switch可以使用字符串。
```Bash
var=ok
case $var in
  ok)
  echo "ok"
  ;;
  notok)
  echo "notok"
  ;;
  *)
  echo "other"
  ;;
esac
```
## 15.4 模块化
### 15.4.1 函数
```bash
myfunc()
{
  echo "first is $1"
  echo "second is $2"
  echo "number is $#"
  return 133
}

myfunc hello world
echo "return value is $?"
```
### 15.4.2 文件包含
```Bash
# this is in a.sh
var=100
```
```Bash
# this is in b.sh
. a.sh
echo $var
```
### 15.4.3 执行脚本
如果在一个脚本A里执行另外一个脚本B，那么和使用`. a.sh`是不一样的，它`fork`了新解析器进程来执行脚本。这样，一旦B脚本运行结束，在脚本B中的变量都不存在了，设置的环境变量也不存在了。

## 15.5 输入/输出和重定向
### 15.5.1 命令行参数
执行Bash脚本时，也可以传递命令行参数，在脚本中可以通过`$1`,`$2`等等获取参数，也可以通过`$0`获得脚本文件名，通过`$#`获取脚本参数个数。
### 15.5.2 重定向输入
除了可以通过命令行给Bash脚本传递参数之外，也可以通过标准输入提供参数。

在脚本中可以通过`read`获取标准用户输入。

也可以通过重定向，将文件内容输入到参数。

### 15.5.3 退出码
运行脚本其实是脚本解析器在运行脚本，脚本解析器进程退出时，就像其他进程退出一样，有退出码，通过`$?`可以获取进程退出码。

### 15.5.4 重定向输出
重定向输出与重定向出入差不多，通过`>`可以将标准输出重定向到文件，而`>>`则表示追加方式写入文件。

### xargs
xargs和重定向配合，用来将之前命令的输出的每一个元素，作为后面一个命令的参数，进行执行。所以后面的命令有可能会执行多次。

## 15.6 高级Bash命令和正则表达式
### 15.6.1 正则表达式
正则表达式是用一种规则字符串来表示一类字符串的工具，在搜索匹配方面非常有用。比如在一个文档中，搜索所有的email，或者电话号码等。

正则表达式参考：
[http://www.runoob.com/regexp/regexp-tutorial.html](http://www.runoob.com/regexp/regexp-tutorial.html)
[http://www.jb51.net/tools/zhengze.html](http://www.jb51.net/tools/zhengze.html)

#### 15.6.1.1 例子
参考内容：
```
hi, tom, i am john.
do you know what is his name.
which is your name, 010-11112222 or 0756-2222111
my email is hi@xueguoliang.cn, what is yours.
my email is xxx@163.com, his is is yyy@yahoo.cc
this is my website http://xueguoliang.cn
which site are you reading?
oh, it is https://www.51job.com/index.html
```
把参考内容写入a.txt，然后输入以下命令：

``` Bash
grep -P "\b0[1-9][0-9]{1,2}-[1-9][0-9]{6,7}\b" a.txt
```
其中
```
\b0[1-9][0-9]{1,2}-[1-9][0-9]{6,7}\b
```
是正则表达式，该表达式表示了电话号码的规则。

#### 15.6.1.2 元字符和转义
正则表达式规定一些字符来表示简单规则，这些被称之为元字符。
|元字符|规则|
|---|---|
|.|	匹配除换行符以外的任意字符
|\w|	匹配字母或数字或下划线或汉字
|\s	|匹配任意的空白符
|\d	|匹配数字，在grep中要使用-P参数才能使用该元字符
|\b	|匹配单词的开始或结束
|^|	匹配字符串的开始
|$|	匹配字符串的结束
|\W	|匹配任意不是字母，数字，下划线，汉字的字符
|\S|	匹配任意不是空白符的字符
|\D	|匹配任意非数字的字符
|\B	|匹配不是单词开头或结束的位置
|[a-z]|匹配a到z的任意一个字符
|[0-9]|匹配数组0-9|
|[acek-i]|匹配一些字母
|[^x]|	匹配除了x以外的任意字符
|[^aeiou]|	匹配除了aeiou这几个字母以外的任意字符

如果需要搜索元字符，那么需要转义，比如想搜索文章中的`$`，那么需要使用`\$`来表示。

正则表达式由原字符和普通字符组成，匹配会一个个字符进行。

#### 16.6.1.3 重复
字符或者元字符可以通过定义重复次数，比如搜索有重复的字母。

|重复符号|解释|
|---|---|
|*|	重复零次或更多次
|+|	重复一次或更多次
|?|	重复零次或一次
|{n}|	重复n次
|{n,}|	重复n次或更多次
|{n,m}|	重复n到m次

#### 16.6.1.4 分组
如果想实现子规则重复，那么需要使用分组。使用`()`进行分组，并且使用`\1`,`\2`来表示组号。

#### 16.6.1.5 选择
使用`|`表示选择，即匹配其中之一便可。

#### 16.6.1.6 贪婪和懒惰
当使用`a+`时，表示匹配一个或者多个a，如果内容有`aaaa`，那么可以匹配a,aa,aaa,aaaa，那么正则表达式默认是使用贪婪方式匹配，即匹配尽可能长的字符串。如果有`?`，则表示懒惰匹配：`a+?`

代码/语法	说明
*?	重复任意次，但尽可能少重复
+?	重复1次或更多次，但尽可能少重复
??	重复0次或1次，但尽可能少重复
{n,m}?	重复n到m次，但尽可能少重复
{n,}?	重复n次以上，但尽可能少重复

### 15.6.2 awk
参考：
[http://xueguoliang.cn/awk](http://xueguoliang.cn/awk)
[http://awk.readthedocs.io/en/latest/index.html](http://awk.readthedocs.io/en/latest/index.html)


#### 15.6.2.1 前言
awk是一个特别删除处理表格数据的字符串处理工具。比如打印所有运行的进程号：
```Bash
ps aux | awk '{print $2}'
```

一个更加全面的例子：
```
ps aux | awk '$3 > 0.0 {print $2, $3}'
```
打印第三列（占用CPU）大于0.0的进程号和占用CPU的百分比。

#### 15.6.2.2 awk结构
```
awk 'pattern { action }'
```
pattern是模版，action是对应的动作。

#### 15.6.2.3 输出
ation最简单的做法就是通过print进行输出。
`$0`表示输出整行
`$1`表示输出第一列
`$2`表示输出第二列
以此类推。
可以使用`NF`来表示字段数量，`$NF`来表示最后一列

#### 15.6.2.4 pattern
pattern表示匹配模式，用来选择处理行。比如`$3>0.01`
其他匹配模式
1. BEGIN { 语句 }
在读取任何输入前执行一次 语句
2. END { 语句 }
读取所有输入之后执行一次 语句
3. 表达式 { 语句 }
对于 表达式 为真（即，非零或非空）的行，执行 语句
4. /正则表达式/ { 语句 }
如果输入行包含字符串与 正则表达式 相匹配，则执行 语句
5. 组合模式 { 语句 }
一个 组合模式 通过与（&&），或（||），非（|），以及括弧来组合多个表达式；对于组合模式为真的每个输入行，执行 语句
6. 模式1，模式2 { 语句 }
范围模式(range pattern)匹配从与 模式1 相匹配的行到与 模式2 相匹配的行（包含该行）之间的所有行，对于这些输入行，执行 语句 。


### 15.6.3 sed
参考
[http://man.linuxde.net/sed](http://man.linuxde.net/sed)
[http://sed.sourceforge.net/sed1line_zh-CN.html](http://sed.sourceforge.net/sed1line_zh-CN.html)



#### 15.6.3.1 前言
sed算是一种批处理编辑器。它的功能是读取文件内容的一行，然后按照指定规则处理，然后输出。之后再重复处理下一行，直到文件末尾。

#### 15.6.3.2 命令格式
```
sed [options] 'command' file(s)
```
其中[option]是可选的，此处不讨论。'command'指sed命令，是讨论的重点。

sed命令列表
|命令|解析|
|---|---|
|a\ |在当前行下面插入文本。
|i\ |在当前行上面插入文本。
|c\ |把选定的行改为新的文本。
|d |删除，删除选择的行。
|D |删除模板块的第一行。
|s| 替换指定字符
|h |拷贝模板块的内容到内存中的缓冲区。
|H |追加模板块的内容到内存中的缓冲区。
|g |获得内存缓冲区的内容，并替代当前模板块中的文本。
|G |获得内存缓冲区的内容，并追加到当前模板块文本的后面。
|l |列表不能打印字符的清单。
|n |读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。
|N |追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。
|p |打印模板块的行。
|P(大写) |打印模板块的第一行。
|q |退出Sed。
|b lable| 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。
|r file |从file中读行。
|t label| if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。
|T label |错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。
|w file |写并追加模板块到file末尾。
|W file |写并追加模板块的第一行到file末尾。
|! |表示后面的命令对所有没有被选定的行发生作用。
|= |打印当前行号码。
|# |把注释扩展到下一个换行符以前。
