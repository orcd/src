
<!-- toc orderedList:0 -->

- [第十七章 命令行版本局域网聊天](#第十七章-命令行版本局域网聊天)
	- [17.1 前言](#171-前言)
	- [17.2 软件功能分析](#172-软件功能分析)
		- [17.2.1 输入命令](#1721-输入命令)
		- [17.2.2 系统设计](#1722-系统设计)
		- [17.2.3 流程分析](#1723-流程分析)
			- [17.2.3.1 启动](#17231-启动)
			- [17.2.3.2 设置账户名](#17232-设置账户名)
			- [17.2.3.2 发送聊天信息](#17232-发送聊天信息)
			- [17.2.3.2 接收聊天信息](#17232-接收聊天信息)
			- [17.2.3.2 发送文件](#17232-发送文件)
			- [17.2.3.2 接收发送文件](#17232-接收发送文件)
		- [17.2.4 通信报文设计](#1724-通信报文设计)
			- [17.2.4.1 上线](#17241-上线)
			- [17.2.4.2 设置名字](#17242-设置名字)
			- [17.2.4.3 发送信息](#17243-发送信息)
			- [17.2.4.4 发送文件](#17244-发送文件)
			- [17.2.4.4 请求文件](#17244-请求文件)
			- [17.2.4.5 文件传输格式](#17245-文件传输格式)
	- [17.3 软件设计](#173-软件设计)
		- [17.3.1 数据结构](#1731-数据结构)
			- [17.3.1.1 账户数据结构](#17311-账户数据结构)
			- [17.3.1.2 文件传输会话结构](#17312-文件传输会话结构)
			- [17.3.1.3 锁](#17313-锁)

<!-- tocstop -->

# 第十七章 命令行版本局域网聊天
## 17.1 前言
本章描述Linux系统编程阶段大练习，实现命令行版本的局域网聊天软件，功能类似飞秋。

## 17.2 软件功能分析
### 17.2.1 输入命令
| 命令  | 解释  |
|---|---|
| set **用户名**  | 设置本端用户名，默认为机器名 (废弃)|
| addg **组名**  | 加入组，可以执行多次以加入多个组（E） |
| send **用户** **信息**  | 给**用户**发送**信息**（A） |
|sendg **组** **信息**|给**组**发送信息（E）|
|send 255.255.255.255 **信息**|给所有人发送**信息** （A）|
|sendf **用户** **文件列表**|给**用户**发送**文件列表** （C）|
|sendfg **组** **文件列表**| 给**组**发送**文件列表**（E）|
|sendfa **文件列表**|给所有人发送**文件列表** （C）|
|list |查询账户列表 （A）|
|update|刷新用户信息 （A）|

### 17.2.2 系统设计
局域网聊天软件程序是采用无服务器设计，因此不需要登陆等流程，当一个用户上线时，以广播方式通知其他用户，以建立通信管道。

系统要处理两方面的输入：
- 用户输入命令
- 网络消息

因此如果使用单线程设计，则需要使用多路IO复用技术，但是考虑到用户输入比较特殊，因此不采用单线程，而是使用多线程实现该功能。

两个常驻线程：
主线程
网络线程

一个临时线程：
文件请求线程

常驻进程：
文件请求进程

临时进程
传输文件（一个文件或者目录）

线程包括：
- 主线程：负责处理用户输入
- 网络线程：负责处理网络输入
- 文件请求线程：负责文件请求的发送
- 文件发送服务线程（进程）：负责接收文件请求连接（setcwd)
- 文件发送线程（进程）：负责文件发送


### 17.2.3 流程分析

#### 17.2.3.1 启动
```{mermaid}
sequenceDiagram
用户->>程序:启动
程序->>程序: 启动其他工作线程，初始化全局数据
程序->>其他账户:广播上线信息给其他账户
程序->>程序: 等待用户输入
其他账户->>程序:响应，返回账户名
程序->>程序: 记录其他系统的账户名到列表
```

#### 17.2.3.2 设置账户名
```{mermaid}
sequenceDiagram
用户->>程序:输入set命令
程序->>其他账户:广播用户名给其他账户
其他账户->>程序:响应，返回账户名
程序->>程序: 记录本程序账户信息
程序->>用户: 显示成功信息
```

#### 17.2.3.2 发送聊天信息
```{mermaid}
sequenceDiagram
用户->>程序:输入send/g/a命令
程序->>其他账户:发送信息给其他账户
```
如果单发给一个账户，那么直接使用UDP发送即可，如果是发送给组或者所有人，则需要用广播发送。

#### 17.2.3.2 接收聊天信息
```{mermaid}
sequenceDiagram
其他账户->>程序:发送信息
程序->>用户:显示信息
```
如果是组信息，则判断程序是否属于该组，如果是则显示，如果不是则丢弃。

#### 17.2.3.2 发送文件
```{mermaid}
sequenceDiagram
用户->>程序:输入sendf/g/a命令
程序->>其他账户:发送信息给其他账户
```

#### 17.2.3.2 接收发送文件
```{mermaid}
sequenceDiagram
其他账户->>程序:sendf/g/a命令
程序->>程序:启动文件请求线程
程序->>其他账户:发送文件请求
其他账户->>程序:传输文件
```
文件请求和发送使用TCP

### 17.2.4 通信报文设计
通信报文采用json格式
#### 17.2.4.1 上线
请求
```json
{
  cmd:"online",
	name:"name"
}
```
响应
```json
{
  cmd:"onlineack",
  name:"peername"
}
```

#### 17.2.4.2 设置名字
请求
```json
{
  cmd:"set",
  name: "myname"
}
```

> 思考，怎么避免两个用户同时设置同一个名字？

#### 17.2.4.3 发送信息
请求
```json
{
  cmd:"send/g/a",
  username:"username"
  msg:"msg body"
}
```

#### 17.2.4.4 发送文件
请求
```json
{
  cmd:"sendf/g/a",
  username:"username"
  files:[
    "filepath1",
    "filepath2",
    "filepath3"
  ]
}
```

#### 17.2.4.4 请求文件
请求
```json
{
  cmd:"get",
  username:"username"
  path:"filepath"
}
```
文件发送和接收通过独立线程来完成，每个文件一个线程。

#### 17.2.4.5 文件传输格式
文件传输包含了文件描述信息和文件内容，为了避免粘包问题，不采用json格式。格式如下：
```
[2个字节文件名长度][文件名][4个字节文件长度][文件内容]
```
2个字节文件名长度和4个字节文件长度，都采用网络序。

## 17.3 软件设计
### 17.3.1 数据结构
#### 17.3.1.1 账户数据结构
```C++
typedef struct User
{
  std::string name;
  std::list<std::string> groups;
  int fd_msg;
  int fd_file_server;
} User;

User g_user;

typedef struct Other
{
  std::string name;
  std::string ip;
} Other;

//std::list<Other*> g_others;
// 以ip地址为key，比链表更加合适，为什么？
std::map<std::string, Other*> g_others;
```

#### 17.3.1.2 文件传输会话结构
每个用户可能都正在发送或者接收文件，文件的发送和接收都不是一下子结束的，需要用一个数据结构记录这个信息。

```C++
typedef struct SendFile
{
  std::string path;
  std::string peerip;
  int fd;
  int filelen;
  int sendlen;
} SendFile;

typedef struct RecvFile
{
  std::string path;
  std::string filename;
  int fd;
  int filelen;
  int recvlen;
} RecvFile;

std::list<SendFile*> g_sending_files;
std::list<SendFile*> g_already_send_files;
std::list<RecvFile*> g_recving_files;
std::list<RecvFile*> g_already_recv_files;
// 文件传输会话，能提供一次传输成功或者失败信息
std::map<std::string, std::list<RecvFile*> > g_sessions;
```
> 可以增加命令来查询历史发送的文件和接收的文件，已经正在发送和接收的文件。

#### 17.3.1.3 锁

```C++
pthread_mutex_t g_mutex;
```
由于有多个线程，这些线程操作全局数据时，需要加锁，为了简化设计，这里只用一把锁。
